### 静态与动态

> 静态是指程序执行之前，从代码就可以知道一切，程序静态的部分包括变量，方法的名称，类型以及控制程序的结构等等

> 相对于静态，动态是指在程序执行之前有些地方是不知道的，程序动态的部分包括变量的值，执行时间和使用的内存等等

#### 静态类型和动态类型
编程语言中的类型是指数据的种类，例如int，string。 在程序中，可以指定变量的数据类型，这个就是静态数据类型的开始，这种对数据类型的定义称为类型的定义，
如果在程序中，将string类型赋值给int类型的变量，那么根据程序的定义，编译器知道赋值语句中的值的类型，所以可以检查这种类型的不匹配的错误，静态类型不用执行程序就可以检测到错误。

动态类型，定义一个变量，这个变量没有声明数据的类型，而是在执行的时候，才知道数据的类型，这样的数据类型称为动态类型。（在执行的时候，有类型检查，一旦发现有不正确的处理，程序就会停止执行）


C++, 所有数据类型都是静态类型，包括对象。

这个原则就是子类对象可以看成父类对象。具体来讲，如果String类是Object类的子类的话，那么String类的所有对象都可以看成Object类的对象。

根据这个原则，在编译是就可以知道变量或者算式的类型，又可以根据执行时的数据类型自动选择合适的处理，从而同时具备了静态类型的优点，和动态类型的多态性，因为在编译的时候，提前知道了变量和算式类型，
所以可以在执行前就发现类型不匹配的错误，另外，根据类型信息在编译时大胆进行优化，可以提高程序的执行速度

对象保存有关自己种类的信息，某一个变量可以用各种类型的数据来赋值，这两点是多态这个面向对象的必要条件，因为如果变量类型和赋值数据的类型必须是完全一致的静态类型的话，成为执行时，就不可嗯根据数据类型的
不来自动选择合适的处理方法。

##### 静态类型的优缺点
静态类型最大的优点是在编译时发现类型不匹配的错误。明确了数据类型，编译时可以对程序进行优化，提高程序的执行速度。还可以在阅读代码时，知道这个类型的信息。  而动态类型的编程语言至多能发现程序的语法错误。


缺点，若不是指定类型就写不出程序，数据类型的定义太繁琐，容易膨胀。另一个问题是，灵活性的问题，静态类型本身限制了给某个变量只能赋值某种类型的对象。这种限制很可能妨碍将来的变化，在多重继承，和接口会比较困难。

##### 动态类型的优缺点
动态类型编程语言最大优点就是源代码变得很简洁。我们在编写程序的时候，可以不考虑数据类型这种无关本质的部分。提高生产力。
由于简洁，动态类型编程语言可能会更好理解。
由于动态类型程序执行时，要做类型检查，静态类型的编程语言通过吧程序源代码转换为可以执行的形式，而动态类型的编程语言，边解释源代码（转换为内部形式），边执行。会比较影响速度。随着计算机性能的提高，执行速度不是什么严重的问题。

#### Duck Typing
表达动态类型灵活性的概念， Duck Typing

意思就是走起路来，像鸭子，叫起来像鸭子，那么他就是鸭子。

从这里可以推导出这样的规则： 如果行为像鸭子，那么不管它是什么，就把它看作鸭子。根本不考虑一个对象属于什么类，只关心它有什么样的行为(它有那么些方法)
动态类型语言用Duck Typing遵循的原则是， 避免明确类型的检查，如果以类为基进行类型检查的话，那么就会像静态编程语言一样失去灵活性。无论如何都想检查的话，也不要检查对象是否属于某个类，而是要检查对象是否有某个方法。

动态类型的缺点主要有三个，即在执行时，才能发现错误，读程序可用到的线索少，以及运行速度慢
分别解决方法： 单元测试，源代码编写文档，计算机的性能



#### Duck Typing与 typescript

在 TypeScript官方文档上有这样一句话
> One of TypeScript's core principles is that type-checking focuses on the shape that values have. this is sometimes called "duck typing" or "structural subtyping". In Typescript, interfaces fill the role of naming these types, and are a powerful way of defining constracts within your code as well as constracts with code outside for your project.

即TypeScript，可以灵活地使用鸭子类型进行编程，因为TypeScript的本质上是JavaScritpt，动态编程的语言，即使添加class，interface的定义，但本质上还是基于prototype chain去实现class的面向编程。

